from machine import Pin, PWM, ADC, I2C
from neopixel import NeoPixel
import framebuf
import utime
import ssd1306
import time

i2c = I2C(0, scl=Pin(22), sda=Pin(23))  
oled = ssd1306.SSD1306_I2C(128, 32, i2c)

# ðŸ“Œ Logo en formato MONO_VLSB (asegurar 1024 bytes)
logo_umb = bytearray([
0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x0f, 0x0f, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x43, 0xe3, 0xe3, 0xe1, 0xe1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 
0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 
0xf9, 0xfd, 0x7d, 0x7d, 0x7d, 0x3d, 0xbd, 0xbd, 0x9d, 0xdd, 0xdd, 0xdd, 0xdd, 0xfd, 0xfd, 0xfd, 
0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xfb, 0xfb, 0xf3, 0xd3, 0xc3, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x0f, 0x0f, 0x0f, 0xff, 0xff, 0xf7, 0x07, 0x07, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xa0, 
0xa0, 0xb2, 0xf7, 0xff, 0x7f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xe7, 0xeb, 0xeb, 0xfc, 0xde, 0xdf, 0xbf, 0x3f, 0x3f, 0x7f, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xef, 0xef, 0xef, 0xef, 0xef, 0xef, 0xaf, 0xaf, 
0xaf, 0xaf, 0xaf, 0xcf, 0xcf, 0xcf, 0xcf, 0xc7, 0xc7, 0xc7, 0xc7, 0xc2, 0xc2, 0xc2, 0xc0, 0xc0, 
0xc0, 0xc0, 0xc0, 0xc0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xf8, 
0xf9, 0xff, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xfd, 0xfd, 0xfe, 0xfe, 0xfe, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xef, 0xef, 0xef, 0xef, 0xef, 0xef, 0xef, 0xef, 0xef, 0xef, 0xef, 0xef, 
0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 
0xfe, 0xee, 0xec, 0xec, 0xec, 0xf8, 0xf8, 0xff, 0xff, 0xf7, 0xf0, 0xf8, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xc0, 0xc0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x9f, 0xbf, 0xbf, 0xff, 0xff, 
0x7f, 0x7f, 0x7f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0x7f, 0xff, 0xff, 0xff, 0xbf, 0xbf, 
0x9f, 0x80, 0x80, 0x80, 0xc0, 0xc0, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0x9f, 0x87, 0x83, 
0x80, 0x80, 0xc0, 0xf0, 0xf8, 0xf8, 0xf8, 0xf1, 0xf1, 0xf1, 0xe3, 0xe3, 0xc7, 0xc7, 0xc7, 0x8f, 
0x8f, 0x9f, 0x9f, 0x9f, 0x9f, 0xcf, 0xcf, 0xcf, 0xe7, 0xe7, 0xe7, 0xf3, 0xf3, 0xf9, 0xf9, 0xfd, 
0xf8, 0xe0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x83, 0x8f, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xff, 0xff, 0xff, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 
0xf7, 0xf7, 0xf6, 0xb2, 0xa0, 0x80, 0x88, 0x88, 0x88, 0x8c, 0x8d, 0xcf, 0xdf, 0xff, 0xff, 0xff
] + [0x00] * (1024 - len([
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0x7f, 0x3f, 0x3f, 0x3f, 0x1f, 
])))

    # ðŸ“Œ Dibujar la imagen manualmente
for y in range(32):
    for x in range(128):
        byte_index = (x + (y // 8) * 128)
        bit_position = y % 8
        pixel_on = (logo_umb[byte_index] >> bit_position) & 1
        oled.pixel(x, y, pixel_on)

oled.show()
time.sleep(3)
oled.show()
oled.fill(1)
oled.show()

# FunciÃ³n para mapear valores
def map_range(value, in_min, in_max, out_min, out_max):
    return int((value - in_min) * (out_max - out_min) / (in_max - in_min) + out_min)

def main():
    servo = PWM(Pin(13))
    servo.freq(50)

    pixels = NeoPixel(Pin(15), 16)

    pot = ADC(Pin(34))
    pot.atten(ADC.ATTN_11DB)

    joy_x = ADC(Pin(32))  # Eje X del joystick
    joy_x.atten(ADC.ATTN_11DB)

    joy_y = ADC(Pin(35))  # Eje Y del joystick
    joy_y.atten(ADC.ATTN_11DB)

    rainbow = [
        (255, 255, 255), (114, 13, 0), (102, 25, 0), (90, 37, 0),
        (78, 49, 0), (66, 61, 0), (54, 73, 0), (42, 85, 0),
        (30, 97, 0), (18, 109, 0), (6, 121, 0), (0, 122, 5),
        (0, 110, 17), (0, 98, 29), (0, 86, 41), (42, 85, 0)
    ]

    angulo = 0
    moving_forward = True
    step_size = 180 // 16  

    while True:

        pot_value = pot.read()
        speed_delay = map_range(pot_value, 0, 4095, 500, 2000)

        joy_x_value = joy_x.read()  
        joy_y_value = joy_y.read()

        red_intensity = map_range(joy_y_value, 0, 4095, -255, 255)
        blue_intensity = map_range(joy_y_value, 0, 4095, 255, -255)

        rotation_speed = map_range(joy_x_value, 0, 4095, -2, 2)

        for _ in range(16):
            if moving_forward:
                angulo += step_size
                if angulo >= 180:
                    angulo = 180
                    moving_forward = False  
            else:
                angulo -= step_size
                if angulo <= 0:
                    angulo = 0
                    moving_forward = True  

            servo.duty(map_range(angulo, 0, 180, 25, 125))

            # RotaciÃ³n del LED blanco con el joystick en X
            if rotation_speed > 0:
                for _ in range(rotation_speed):
                    rainbow.append(rainbow.pop(0))
                    
            elif rotation_speed < 0:
                for _ in range(abs(rotation_speed)):
                    rainbow.insert(0, rainbow.pop())

            # Ajustar colores sin cambiar el blanco
            for i in range(16):
                r, g, b = rainbow[i]
                if (r, g, b) != (255, 255, 255):  
                    r = max(0, min(255, r + red_intensity))
                    b = max(0, min(255, b + blue_intensity))
                pixels[i] = (r, g, b)  
            
            pixels.write()
            utime.sleep_ms(speed_delay // 16)

        oled.fill(1)

        if blue_intensity == 255 :
            oled.text(f"Azulito", 15,23,0)
        elif blue_intensity == -255 :
            oled.text(f"Rojo", 15,23,0)
        else: 
            oled.text(f"Neutro", 15,23,0)

        oled.text(f"Velocidad: {rotation_speed}",15,5,0)
        oled.text(f"Poten: {speed_delay}",15,14,0)
        oled.show()
        

if __name__ == "__main__":
    main()
